---
title: "Example of qPCR Pipeline Usage"
subtitle: "Copy number GAPDH normalised dataset"
author: "Michal Varga"
date: "Last edited: `r format(Sys.time(), '%Y-%m-%d')`"
output: rmarkdown::github_document
params:
    target_gene: bIFIT1
    primer_set: PS11
    cell_line: MDBK
    housekeeping_gene: bGAPDH
    conditions: !r c('Mock', 'hRSV 1-24', 'bRSV dSH 1-24', 'bIFNa 5-24')
editor_options: 
  markdown: 
    wrap: 72
---

```{r knitr_libraries, include=F}
library(knitr)
library(kableExtra)
library(rmarkdown)
```

# Introduction

Purpose: 

based on scripts:

-   [standard curve](/Scripts/standard_curve.R)
-   [control gene Ct based](/Scripts/standard_curve.R)
-   [Copy number GAPDH normalised dataset](/Scripts/standard_curve.R)

parameters incuded in script:

-   `target_gene:` bIFIT1
-   `primer_set`: PS11
-   `housekeeping_gene:` bGAPDH
-   `cell_line`: MDBK
-   `conditions:` !r c('Mock', 'hRSV 1-24', 'bRSV dSH 1-24', 'bIFNa 5-24')

Link to [stats pipeline]()

## Libraries (maybe put them when they are used?)

```{r required_libraries, warning=FALSE, message=FALSE}
library(tidyverse) # for data manipulation
library(data.table) # for fast data reading and writing
library(scales) # for log10 axis on figures
```

# 1. Standard Curve

## Introduction

Some text about what the fuck

## Data Loading

Load `standard_curves_data.csv` from `/Data` folder, and filter the target gene and primer set used based on the declared parameters in YAML.

```{r data_loading_standard_curve}
standard_curve_data <- fread('../Data/standard_curves_data.csv') %>%
  filter(Target == params$target_gene,
         Primer_set == params$primer_set)
```
```{r data_loading_standard_curve_display, echo=FALSE, warning=FALSE}
standard_curve_data |> kable()
```

## Linear Model Production
### Construct Linear Model

Text about what we do in this step

```{r standard_curve_model}
model_standard_curve <- lm(log10(Copy_number)~Ct, data = standard_curve_data)
```
```{r standard_curve_model_display, echo=FALSE, warning=FALSE}
lm(log10(Copy_number)~Ct, data = standard_curve_data)
```

### Construct a Prediction Based on the Linear Model

Text about what we do in this step

```{r standard_curve_model_prediction}
prediction_model_standard_curve <- 10^predict(
  model_standard_curve, 
  interval = 'prediction')
```
```{r standard_curve_model_prediction_display, echo=FALSE, warning=FALSE}
10^predict(
  model_standard_curve, 
  interval = 'prediction'
  ) |> kable()
```


Text about what we do in this step

```{r standard_curve_dataset_bind}
data_combined_standard_curve <- cbind(
  standard_curve_data,
  prediction_model_standard_curve)
```
```{r standard_curve_dataset_bind_display, echo=FALSE, warning=FALSE}
cbind(
  standard_curve_data,
  prediction_model_standard_curve
  ) |> kable()
```


### Calculate Amplification Efficiency

Some text about what the fuck are we doing


```{math}
\text{Amplification Efficiency} = 10^{-1/\text{slope}}-1
```

```{r standard_curve_amplification_efficiency}
efficiency_standard_curve <- paste(
  round(
    (10^(-1/ lm(Ct~log10(Copy_number),
                data = standard_curve_data)[[1]][2]) -1)*100,
    digits = 2),
  '% Amplification Efficiency',
  sep = '')
```
```{r standard_curve_amplification_efficiency_display, echo=FALSE, warning=FALSE}
paste(
  round(
    (10^(-1/ lm(Ct~log10(Copy_number), 
                data = standard_curve_data)[[1]][2]) -1)*100, 
    digits = 2), 
  '% Amplification Efficiency', 
  sep = ''
  )
```

## Figure of Standard Curve
### Constructing Figure

Text about what we do in this step

```{r standard_curve_figure_parameters}
plot_title_standard_curve <- paste(params$target_gene, 
                    '-', 
                    params$primer_set,
                    'Standard Curve', 
                    sep = " ")
x_annotation_position_standard_curve <- 1000000
y_annotation_position_standard_curve <- 37.5
top_range_standard_curve <- 40
y_axis_title_standard_curve <- 'Cycle Threshold'
x_axis_title_standard_curve <- 'Copy Number'
```

Text about what we do in this step

```{r standard_curve_figure_initial_ggplot}
plot_standard_curve <- ggplot(
  data = data_combined_standard_curve,
  mapping = aes(x = Copy_number,
                y = Ct)) +
  geom_point() +
  stat_smooth(method = lm) +
  labs(
    title = plot_title_standard_curve,
    y = x_axis_title_standard_curve,
    x = y_axis_title_standard_curve)
```

Text about what we do in this step

```{r standard_curve_figure_y_axis}
plot_standard_curve <- plot_standard_curve +
  scale_y_continuous(
    breaks = seq(from = 0, 
                 to = top_range_standard_curve, 
                 by = 10),
    limits = c(0,top_range_standard_curve))
```

Text about what we do in this step

```{r standard_curve_figure_log_scale}
plot_standard_curve <- plot_standard_curve +
  scale_x_log10(
    labels = trans_format("log10", 
                          math_format(10^.x)),
    breaks = trans_breaks("log10", 
                          function(x) 10^x)) +
  annotation_logticks(sides='b')
```

Text about what we do in this step

```{r standard_curve_figure_theme}
plot_standard_curve <- plot_standard_curve +
  theme_bw() +
  theme(
  plot.title = element_text(
    size = 15, 
    face = 'bold', 
    margin = margin(8, 0, 8, 0), 
    hjust = 0.5),
  axis.text.y = element_text(
    angle = 0, 
    size = 9, 
    vjust = 0.5),
  axis.text.x.bottom = element_text(
    angle = 0, 
    size = 9, 
    vjust = 0.5),
  axis.title.x = element_text(
    size = 12, 
    face = 'bold', 
    vjust = -0.5, 
    margin = margin(0, 8, 0, 0)),
  axis.title.y = element_text(
    size = 12, 
    face='bold', 
    vjust=-0.5, 
    margin = margin(0, 8, 0, 0)),
  aspect.ratio = 1/2)
```

Text about what we do in this step

```{r standard_curve_figure_annotation}
plot_standard_curve <- plot_standard_curve +
  annotate('text',
           y = y_annotation_position_standard_curve, 
           x = x_annotation_position_standard_curve, 
           label = efficiency_standard_curve, 
           size = 5)
```
```{r standard_curve_plot_display, , echo=FALSE, warning=FALSE}
plot_standard_curve
```

### Saving Figure

Text about what we do in this step

```{r standard_curve_figure_save}
ggsave(filename = paste(
  paste("plot_standard_curve", 
                    params$target_gene, 
                    params$primer_set,
                    sep = "_"), '.png', sep = ''), 
       plot = plot_standard_curve, 
       device = 'png', 
       path = '../Figures', 
       dpi = 600, 
       height = 12, 
       width = 20, 
       units = 'cm')
```

# 2. Housekeeping Gene Control
## Introduction

Some text about what the fuck

## Data Loading

Load `ct_data.csv` from `/Data` folder, and filter the target gene and primer set used based on the declared parameters in YAML.


```{r data_loading_housekeeping}
housekeeping_data <- fread('../Data/ct_data.csv') %>% 
  filter(Target == params$housekeeping_gene, 
         Cell_line == params$cell_line,
         Condition %in% params$conditions)
```
```{r data_loading_housekeeping_display, echo=FALSE, warning=FALSE}
housekeeping_data |> kable()
```

## Processing Data

write about what the fuck is happening

equation for ddCt for housekeeping (CHANGE ME!!!)

```{math}
\text{Relative Quantification} = 2^{\Updelta\Updelta \text{Ct}}
```
```{math}
\Updelta\Updelta \text{Ct} = \Updelta \text{Ct}_{\text{Test Samples}}-\Updelta \text{Ct}_{\text{Calibrator Samples}}
```
```{math}
\Updelta \text{Ct}_{\text{Test Samples}} = \text{Ct}_{\text{Target Gene in Tests}}-\text{Ct}_{\text{Reference Gene in Tests}}
```
```{math}
\Updelta \text{Ct}_{\text{Calibrator Samples}} = \text{Ct}_{\text{Target Gene in Calibrator}}-\text{Ct}_{\text{Reference Gene in Calibrator}}
```


```{r housekeeping_ddct}
ddct_housekeeping_data <- housekeeping_data |> mutate(
  control_mean = mean(
    Ct[Condition == params$conditions[1]],
    na.rm = T),
  log2_dCt = 2^ (- (Ct - control_mean)),
  control_mean_log = mean(
    log2_dCt[Condition == params$conditions[1]],
    na.rm = T),
  Value_normalised = log2_dCt / control_mean_log)
```
```{r housekeeping_ddct_display, echo=FALSE, warning=FALSE}
ddct_housekeeping_data |> kable()
```

## Factorisation

Text about what we do in this step

```{r housekeeping_aggregated}
aggregated_housekeeping_data <- aggregate(x=ddct_housekeeping_data, 
                               by=list(ddct_housekeeping_data$Condition),
                               FUN = mean)
```
```{r housekeeping_aggregated_display, echo=FALSE, warning=FALSE}
aggregated_housekeeping_data |> kable()
```

Text about what we do in this step

```{r housekeeping_arranged}
arranged_aggregated_housekeeping_data <- aggregated_housekeeping_data %>%
  arrange(match(Group.1, params$conditions))
```
```{r housekeeping_arranged_display, echo=FALSE, warning=FALSE}
arranged_aggregated_housekeeping_data |> kable()
```

Text about what we do in this step

```{r housekeeping_factros_vector}
housekeeping_factor_vector <- rep(arranged_aggregated_housekeeping_data$Value_normalised, each=3)
```
```{r housekeeping_factros_vector_display, echo=FALSE, warning=FALSE}
housekeeping_factor_vector |> kable()
```

# 3. Factorised Copy Number Extrapolation

## Introduction

Some text about what the fuck

## Data loading and filtering

Load `ct_data.csv` from `/Data` folder, and filter the target gene and primer set used based on the declared parameters in YAML.

```{r data_loading}
target_data <- fread('../Data/copy_number_extrapolation_data.csv') %>%
  filter(Target == params$target_gene,
         Cell_line == params$cell_line,
         Condition %in% params$conditions)
```

```{r data_loading_display, echo=FALSE, warning=FALSE}
target_data |> kable()
```

## Data Wrangling
### Copy number extrapolation

```{r copy_number_extrapolation}
target_data_modelled <- target_data |> 
  mutate(
    Copy_number = 10^predict(model_standard_curve, 
                             newdata = target_data))
```

```{r copy_number_extrapolation_display, echo=FALSE, warning=FALSE}
target_data_modelled |> kable()
```

### Factorisation based on housekeeping gene levels

wriet about what the fuck is happening

equation for ddCt 

```{math}
\text{Relative Quantification} = 2^{\Updelta\Updelta \text{Ct}}
```
```{math}
\Updelta\Updelta \text{Ct} = \Updelta \text{Ct}_{\text{Test Samples}}-\Updelta \text{Ct}_{\text{Calibrator Samples}}
```
```{math}
\Updelta \text{Ct}_{\text{Test Samples}} = \text{Ct}_{\text{Target Gene in Tests}}-\text{Ct}_{\text{Reference Gene in Tests}}
```
```{math}
\Updelta \text{Ct}_{\text{Calibrator Samples}} = \text{Ct}_{\text{Target Gene in Calibrator}}-\text{Ct}_{\text{Reference Gene in Calibrator}}
```


```{r copy_number_ddct_factorised}
target_data_modelled_ddct_factorised <- target_data_modelled |> 
  mutate(
    Factor = housekeeping_factor_vector,
    Copy_number_modified = Copy_number / Factor,
    Control_mean = mean(
      Copy_number_modified[Condition == params$conditions[1]], 
      na.rm = T
    ),
    Value_normalisedalised = Copy_number_modified / Control_mean
  )
```

```{r copy_number_ddct_factorised_display, echo=FALSE, warning=FALSE}
target_data_modelled_ddct_factorised |> kable()
```

#### Save data

```{r save_data}
fwrite(target_data_modelled_ddct_factorised, 
       paste('../Adjusted-Data/', 
             paste('Analysed', params$target_gene, sep = "_"), 
             '.csv', 
             sep = ''))
```

## Statistics

based on the [statistics pipeline](Reports\Templates\Statistics-pipeline.md)

### Visual Assesment

#### Normal Distribution by Boxplot

```{r stats_boxplot}
boxplot(Value_normalisedalised~Condition, target_data_modelled_ddct_factorised)
```

#### Testing equality of variance assumptions

```{r stats_variance_plots}
plot(lm(Value_normalisedalised~Condition, target_data_modelled_ddct_factorised))
```

**1st and the last plots:** we want symmetrical data about the 0 horizontal line

**2nd plot:** we want residual points to be as close to the predicted line as possible

**3rd plot:** we want for red line to be approx. horizontal

### Assumption of Normality

**p value \> 0.05 means normal distribution**

```{r shapiro.test_single}
shapiro.test(target_data_modelled_ddct_factorised$Value_normalisedalised[1:3]) # test all values in one condition
shapiro.test(target_data_modelled_ddct_factorised$Value_normalisedalised[4:6]) # test all values in one condition
shapiro.test(target_data_modelled_ddct_factorised$Value_normalisedalised[7:9]) # test all values in one condition
```


```{r shapiro.test_total}
shapiro.test(residuals(lm(Value_normalisedalised~Condition, target_data_modelled_ddct_factorised))) # test all values in the whole dataset
```

**NON NORMAL DISTRIBUTION**

### Assumption of homogeniety of variance for non normal distribution

**p value \> 0.05 means equal variance**

```{r leveneTest}
library(car, quietly = TRUE)
leveneTest(Value_normalisedalised~Condition, target_data_modelled_ddct_factorised)
```

**EQUAL VARIANCE OF RESIDUALS**

### Statistical Parameters for Non-Normal Distribution and Equal Variance

```{r kruskal.test}
library(dunn.test, quietly = T)
dunn.test(target_data_modelled_ddct_factorised$Value_normalisedalised, 
          target_data_modelled_ddct_factorised$Condition, 
          altp=T,
          list=T)
```

Kruskal test finds there is any significant difference across the whole dataset. If the p-value is **ABOVE** 0.05 the analysis should be stopped here without comparing groups!

Important parameters: chi-squared and p-value (include in reports)

The dunn test displays both comparison matrix and comparison list of tested groups. P values are the individual p values between group combinations.

**Test passed**

Group-wise comparison is below:

bIFNa 5-24 - Mock          :  1.019049 (0.3082)
bRSV dSH 1-24 - Mock       : -1.019049 (0.3082)
hRSV 1-24 - Mock           :  2.038098 (0.0415)*

## Plotting Final Figure
### Constructing Figure

```{r final_figure_initial_ggplot}
plot_normalised_values <- ggplot(target_data_modelled_ddct_factorised %>% filter(Condition != params$conditions[1])) +
  aes(x = Value_normalisedalised, 
      y = fct_rev(fct_relevel(Condition, 
                              params$conditions[2], 
                              params$conditions[3],
                              params$conditions[4]))) +
  geom_jitter(shape=17, size=2, width = 0, height = 0.3, color="#131112") +
  stat_summary(fun.y=median, geom="point", size=1.8, color="#A41237") 
```



```{r}
plot_normalised_values <- plot_normalised_values +
  labs(
    title = paste("Gene Expression", params$target_gene, sep = " "),
    y = NULL,
    x = 'Fold Change'
  ) +
  scale_x_continuous(trans = log2_trans(),
                     breaks = trans_breaks("log2", function(x) 2^x, n = 8),
                     labels = trans_format("log2", math_format(2^.x)),
                     limits = c(2^-5,2^10),
                     sec.axis = sec_axis(trans = identity,
                                         breaks = c(2^-4, 2^-2, 2^0, 2^2, 2^4, 2^6, 2^8, 2^10),
                                         labels = c(0.062, 0.25, 1, 4, 16, 64, 256, 1024)))
```

```{r}
plot_normalised_values <- plot_normalised_values +
  
  annotate("text", size = 3, fontface = "bold", x = 600, y = params$conditions[2],  label = "0.0415") +
  annotate("text", size = 3, fontface = "bold", x = 600, y = params$conditions[3], label = "0.3082") +
  annotate("text", size = 3, fontface = "bold", x = 600, y = params$conditions[4], label = "0.3082")
```

```{r final_figure_theme}
plot_normalised_values <- plot_normalised_values +
  theme_classic() +
  theme(
    plot.title = element_text(
      size = 15, 
      face = 'bold', 
      margin = margin(0, 0, 5, 0), 
      hjust = 0.5
    ),
    axis.text.y = element_text(
      angle=0, 
      size=9, 
      vjust=0.2),
    axis.title.x = element_text(
      size = 12, 
      face='bold', 
      vjust=-0.5, 
      margin = margin(0, 0, 0, 0)),
    axis.title.y = element_blank(),
    axis.text.x=element_text(
      angle=0, 
      size=9, 
      vjust=0.5),
    axis.ticks.y=element_blank(),
    panel.grid.major.y = element_line(color = "gray86",
                                      size = 0.1,
                                      linetype = 1),
    legend.position = "none",
    aspect.ratio = 1/2)
```

```{r final_figure_annotation_lines}
plot_normalised_values <- plot_normalised_values  +
  geom_vline(xintercept = 1, 
             linetype = "dotted", 
             color = '#2e222f', 
             linewidth = 1) +
  geom_vline(xintercept = 4, 
             linetype = "dotted", 
             color ="#A41237", 
             linewidth = 1) +
  geom_vline(xintercept = 0.25, 
             linetype = "dotted", 
             color = "#A41237", 
             linewidth = 1)
```
```{r}
plot_normalised_values
```

### Save plot

```{r}
ggsave(filename = paste(
  paste("plot_normalised_values", 
                    params$target_gene,
                    sep = "_"), '.png', sep = ''), 
       plot = plot_normalised_values, 
       device = 'png', 
       path = '../Figures', 
       dpi = 600, 
       height = 16, 
       width = 20, 
       units = 'cm')
```

Some final text

